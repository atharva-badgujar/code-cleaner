#!/usr/bin/env python3
"""
Code Cleaner - Professional code cleaning and documentation tool
Supports: Python, JavaScript, TypeScript, Java, C, C++, Go, Rust, PHP
"""

import re
import sys
import os
import subprocess
from pathlib import Path
from typing import List, Optional, Dict
import json
import textwrap

# Language configurations
LANGUAGE_CONFIG = {
    'py': {
        'name': 'Python',
        'single_comment': '#',
        'multi_start': '"""',
        'multi_end': '"""',
        'extensions': ['.py'],
        'indent': '    ',
    },
    'js': {
        'name': 'JavaScript',
        'single_comment': '//',
        'multi_start': '/*',
        'multi_end': '*/',
        'extensions': ['.js', '.jsx'],
        'indent': '  ',
    },
    'ts': {
        'name': 'TypeScript',
        'single_comment': '//',
        'multi_start': '/*',
        'multi_end': '*/',
        'extensions': ['.ts', '.tsx'],
        'indent': '  ',
    },
    'java': {
        'name': 'Java',
        'single_comment': '//',
        'multi_start': '/*',
        'multi_end': '*/',
        'extensions': ['.java'],
        'indent': '    ',
    },
    'c': {
        'name': 'C/C++',
        'single_comment': '//',
        'multi_start': '/*',
        'multi_end': '*/',
        'extensions': ['.c', '.cpp', '.h', '.hpp', '.cc', '.cxx'],
        'indent': '    ',
    },
    'go': {
        'name': 'Go',
        'single_comment': '//',
        'multi_start': '/*',
        'multi_end': '*/',
        'extensions': ['.go'],
        'indent': '    ',
    },
    'rs': {
        'name': 'Rust',
        'single_comment': '//',
        'multi_start': '/*',
        'multi_end': '*/',
        'extensions': ['.rs'],
        'indent': '    ',
    },
    'php': {
        'name': 'PHP',
        'single_comment': '//',
        'multi_start': '/*',
        'multi_end': '*/',
        'extensions': ['.php'],
        'indent': '    ',
    },
}


class CommentRemover:
    """Removes comments while preserving code structure and indentation"""
    
    def __init__(self, lang_code: str):
        self.config = LANGUAGE_CONFIG.get(lang_code, LANGUAGE_CONFIG['py'])
        self.single = self.config['single_comment']
        self.multi_start = self.config['multi_start']
        self.multi_end = self.config['multi_end']
    
    def remove_comments(self, code: str) -> str:
        """Remove comments while preserving exact indentation"""
        lines = code.split('\n')
        result = []
        in_multi = False
        
        for line in lines:
            # Preserve empty lines
            if not line.strip():
                result.append(line)
                continue
            
            # Get original indentation
            indent = len(line) - len(line.lstrip())
            leading_space = line[:indent]
            
            # Check if in multiline comment
            if in_multi:
                if self.multi_end in line:
                    in_multi = False
                    # Check if there's code after the comment end
                    end_idx = line.find(self.multi_end) + len(self.multi_end)
                    remaining = line[end_idx:].strip()
                    if remaining:
                        result.append(leading_space + remaining)
                continue
            
            # Check for multiline comment start
            if self.multi_start in line:
                before_comment = line[:line.find(self.multi_start)].strip()
                if self.multi_end in line:
                    # Single-line multiline comment
                    end_idx = line.find(self.multi_end) + len(self.multi_end)
                    after_comment = line[end_idx:].strip()
                    cleaned = (before_comment + ' ' + after_comment).strip()
                    if cleaned:
                        result.append(leading_space + cleaned)
                else:
                    # Start of multiline comment
                    in_multi = True
                    if before_comment:
                        result.append(leading_space + before_comment)
                continue
            
            # Remove single-line comments while preserving indentation
            cleaned = self._remove_single_line_comment(line)
            if cleaned.strip():  # Only add if not empty
                result.append(cleaned)
        
        return '\n'.join(result)
    
    def _remove_single_line_comment(self, line: str) -> str:
        """Remove single-line comment while preserving indentation"""
        in_string = False
        string_char = None
        
        for i in range(len(line)):
            char = line[i]
            
            # Track strings
            if char in ('"', "'") and (i == 0 or line[i-1] != '\\'):
                if not in_string:
                    in_string = True
                    string_char = char
                elif char == string_char:
                    in_string = False
            
            # Check for comment
            if not in_string and line[i:i+len(self.single)] == self.single:
                return line[:i].rstrip()
        
        return line


class CommentAdder:
    """Adds intelligent comments to code using AI"""
    
    def __init__(self, lang_code: str):
        self.lang = lang_code
        self.config = LANGUAGE_CONFIG.get(lang_code, LANGUAGE_CONFIG['py'])
    
    def add_comments(self, code: str) -> str:
        """Add helpful comments to code"""
        lines = code.split('\n')
        result = []
        
        i = 0
        while i < len(lines):
            line = lines[i]
            stripped = line.strip()
            
            # Skip empty lines and existing comments
            if not stripped or stripped.startswith(self.config['single_comment']):
                result.append(line)
                i += 1
                continue
            
            indent = len(line) - len(line.lstrip())
            leading_space = line[:indent]
            
            # Add comment for function/class definitions
            if self._is_function_def(stripped) or self._is_class_def(stripped):
                comment = self._generate_def_comment(stripped)
                if comment:
                    result.append(f"{leading_space}{self.config['single_comment']} {comment}")
            
            # Add comment for complex logic
            elif self._is_complex_line(stripped):
                comment = self._generate_logic_comment(stripped)
                if comment:
                    result.append(f"{leading_space}{self.config['single_comment']} {comment}")
            
            result.append(line)
            i += 1
        
        return '\n'.join(result)
    
    def _is_function_def(self, line: str) -> bool:
        """Check if line is a function definition"""
        patterns = [
            r'^def\s+\w+',  # Python
            r'^function\s+\w+',  # JavaScript
            r'^(public|private|protected)?\s*(static)?\s*\w+\s+\w+\s*\(',  # Java/C++
            r'^func\s+\w+',  # Go
            r'^fn\s+\w+',  # Rust
        ]
        return any(re.match(p, line) for p in patterns)
    
    def _is_class_def(self, line: str) -> bool:
        """Check if line is a class definition"""
        patterns = [
            r'^class\s+\w+',  # Python/Java/C++
            r'^(public|private)?\s*class\s+\w+',  # Java
            r'^struct\s+\w+',  # C/Rust
        ]
        return any(re.match(p, line) for p in patterns)
    
    def _is_complex_line(self, line: str) -> bool:
        """Check if line contains complex logic"""
        complex_keywords = ['if', 'for', 'while', 'try', 'catch', 'switch', 'case']
        return any(line.startswith(kw) for kw in complex_keywords)
    
    def _generate_def_comment(self, line: str) -> str:
        """Generate comment for function/class definition"""
        if 'class' in line.lower():
            name = re.search(r'class\s+(\w+)', line)
            return f"{name.group(1)} class definition" if name else "Class definition"
        elif any(kw in line for kw in ['def', 'function', 'func', 'fn']):
            name = re.search(r'(?:def|function|func|fn)\s+(\w+)', line)
            return f"Function: {name.group(1)}" if name else "Function definition"
        return ""
    
    def _generate_logic_comment(self, line: str) -> str:
        """Generate comment for logic statements"""
        if line.startswith('if'):
            return "Check condition"
        elif line.startswith('for'):
            return "Loop through items"
        elif line.startswith('while'):
            return "Loop while condition is true"
        elif line.startswith('try'):
            return "Try block for error handling"
        return ""


class SmartFormatter:
    """Intelligent code formatting that preserves structure"""
    
    @staticmethod
    def format_code(code: str, lang: str) -> str:
        """Format code based on language"""
        if lang == 'py':
            return SmartFormatter._format_python(code)
        elif lang in ['js', 'ts']:
            return SmartFormatter._format_javascript(code)
        else:
            return SmartFormatter._format_generic(code, lang)
    
    @staticmethod
    def _format_python(code: str) -> str:
        """Format Python code"""
        try:
            import black
            mode = black.Mode(line_length=88)
            return black.format_str(code, mode=mode)
        except:
            pass
        
        try:
            import autopep8
            return autopep8.fix_code(code, options={'aggressive': 1})
        except:
            pass
        
        return SmartFormatter._format_generic(code, 'py')
    
    @staticmethod
    def _format_javascript(code: str) -> str:
        """Format JavaScript/TypeScript"""
        try:
            result = subprocess.run(
                ['npx', 'prettier', '--parser', 'babel', '--stdin-filepath', 'temp.js'],
                input=code.encode(),
                capture_output=True,
                timeout=5
            )
            if result.returncode == 0:
                return result.stdout.decode()
        except:
            pass
        
        return SmartFormatter._format_generic(code, 'js')
    
    @staticmethod
    def _format_generic(code: str, lang: str) -> str:
        """Basic formatting that preserves indentation"""
        indent_char = LANGUAGE_CONFIG[lang]['indent']
        lines = code.split('\n')
        
        # Just clean up trailing whitespace and excessive blank lines
        result = []
        prev_blank = False
        
        for line in lines:
            # Remove trailing whitespace
            cleaned = line.rstrip()
            
            # Handle blank lines
            if not cleaned:
                if not prev_blank:
                    result.append('')
                    prev_blank = True
            else:
                result.append(cleaned)
                prev_blank = False
        
        return '\n'.join(result)


class QuickGit:
    """Simple git operations"""
    
    @staticmethod
    def auto_push(files: List[str], message: str = "Clean code") -> bool:
        """One-command git add, commit, push"""
        try:
            for f in files:
                subprocess.run(['git', 'add', f], check=True, capture_output=True)
            subprocess.run(['git', 'commit', '-m', message], check=True, capture_output=True)
            result = subprocess.run(['git', 'branch', '--show-current'], 
                                  capture_output=True, text=True, check=True)
            branch = result.stdout.strip()
            subprocess.run(['git', 'push', 'origin', branch], check=True, capture_output=True)
            return True
        except:
            return False


class NPMCacheCleaner:
    """Intelligent NPM cache cleaning"""
    
    def __init__(self):
        self.cache_path = None
        self.cache_size = 0
        self.corrupted_count = 0
        self.stale_packages = []
        self.active_packages = set()
    
    def format_size(self, bytes: int) -> str:
        """Format bytes to human readable"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes < 1024:
                return f"{bytes:.1f} {unit}"
            bytes /= 1024
        return f"{bytes:.1f} TB"
    
    def get_npm_cache_path(self) -> Optional[Path]:
        """Get npm cache directory path"""
        try:
            result = subprocess.run(
                ['npm', 'config', 'get', 'cache'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                cache_path = Path(result.stdout.strip())
                if cache_path.exists():
                    return cache_path
        except:
            pass
        
        # Fallback to default locations
        home = Path.home()
        default_paths = [
            home / '.npm',
            home / 'AppData' / 'Roaming' / 'npm-cache',  # Windows
        ]
        
        for path in default_paths:
            if path.exists():
                return path
        
        return None
    
    def get_folder_size(self, path: Path) -> int:
        """Calculate folder size in bytes"""
        total = 0
        try:
            for item in path.rglob('*'):
                if item.is_file():
                    try:
                        total += item.stat().st_size
                    except:
                        pass
        except (PermissionError, OSError):
            pass
        return total
    
    def find_active_packages(self) -> set:
        """Find packages used in local projects"""
        active = set()
        home = Path.home()
        search_paths = [
            home / 'Desktop',
            home / 'Documents',
            home / 'Downloads',
            home / 'Projects',
            home / 'dev',
            home / 'Development',
        ]
        
        print("üîç Scanning for active Node.js projects...")
        
        for search_path in search_paths:
            if not search_path.exists():
                continue
            
            try:
                for package_json in search_path.rglob('package.json'):
                    if 'node_modules' in package_json.parts:
                        continue
                    
                    try:
                        with open(package_json, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                            
                            # Get dependencies
                            for dep_type in ['dependencies', 'devDependencies']:
                                if dep_type in data:
                                    for pkg in data[dep_type].keys():
                                        active.add(pkg)
                    except:
                        pass
            except:
                pass
        
        return active
    
    def analyze_cache(self) -> Dict:
        """Analyze npm cache and find issues"""
        self.cache_path = self.get_npm_cache_path()
        
        if not self.cache_path:
            return {'error': 'NPM cache directory not found'}
        
        print(f"üì¶ Analyzing npm cache at: {self.cache_path}")
        
        # Get cache size
        self.cache_size = self.get_folder_size(self.cache_path)
        
        # Find active packages
        self.active_packages = self.find_active_packages()
        
        # Check for corrupted entries
        self.corrupted_count = self._check_corrupted()
        
        # Find stale packages
        self._find_stale_packages()
        
        return {
            'cache_path': self.cache_path,
            'total_size': self.cache_size,
            'corrupted_count': self.corrupted_count,
            'stale_count': len(self.stale_packages),
            'active_packages': len(self.active_packages)
        }
    
    def _check_corrupted(self) -> int:
        """Check for corrupted cache entries"""
        corrupted = 0
        
        # Check _cacache/index-v5
        index_path = self.cache_path / '_cacache' / 'index-v5'
        if index_path.exists():
            try:
                for entry in index_path.iterdir():
                    if entry.is_file():
                        try:
                            # Try to read as JSON
                            with open(entry, 'r') as f:
                                f.read()
                        except:
                            corrupted += 1
            except:
                pass
        
        return corrupted
    
    def _find_stale_packages(self):
        """Find packages not used in any active project"""
        # This is a simplified check
        # In real npm cache, packages are stored as hashes
        # We'll estimate based on cache age
        
        import time
        thirty_days_ago = time.time() - (30 * 24 * 60 * 60)
        
        content_path = self.cache_path / '_cacache' / 'content-v2'
        if content_path.exists():
            try:
                for item in content_path.rglob('*'):
                    if item.is_file():
                        try:
                            mtime = item.stat().st_mtime
                            if mtime < thirty_days_ago:
                                self.stale_packages.append(item)
                        except:
                            pass
            except:
                pass
    
    def show_analysis(self, info: Dict):
        """Display cache analysis"""
        print(f"\n{'='*70}")
        print("üìä NPM Cache Analysis")
        print(f"{'='*70}\n")
        
        print(f"üìç Cache Location: {info['cache_path']}")
        print(f"üíæ Total Size: {self.format_size(info['total_size'])}")
        print(f"üì¶ Active Packages (in use): {info['active_packages']}")
        print(f"üóëÔ∏è  Stale Packages (>30 days): {info['stale_count']}")
        
        if info['corrupted_count'] > 0:
            print(f"‚ö†Ô∏è  Corrupted Entries: {info['corrupted_count']}")
        
        # Estimate cleanable space
        stale_size = sum(p.stat().st_size for p in self.stale_packages if p.exists())
        
        print(f"\nüí∞ Estimated Recoverable Space: {self.format_size(stale_size)}")
        print(f"{'='*70}\n")
    
    def clean_cache(self, mode: str = 'smart') -> bool:
        """Clean npm cache based on mode"""
        
        if mode == 'verify':
            print("üîç Verifying npm cache...")
            try:
                result = subprocess.run(
                    ['npm', 'cache', 'verify'],
                    capture_output=True,
                    text=True
                )
                print(result.stdout)
                return result.returncode == 0
            except:
                print("‚ùå Failed to verify cache")
                return False
        
        elif mode == 'force':
            print("‚ö†Ô∏è  This will delete ALL cache (like npm cache clean --force)")
            confirm = input("Continue? (y/n): ").strip().lower()
            
            if confirm != 'y':
                print("Cancelled.")
                return False
            
            print("üßπ Cleaning entire cache...")
            try:
                result = subprocess.run(
                    ['npm', 'cache', 'clean', '--force'],
                    capture_output=True,
                    text=True
                )
                if result.returncode == 0:
                    print(f"‚úì Cache cleaned! Freed: {self.format_size(self.cache_size)}")
                    return True
                else:
                    print("‚ùå Failed to clean cache")
                    return False
            except:
                print("‚ùå npm command failed")
                return False
        
        elif mode == 'smart':
            print("üéØ Smart cleaning (removes stale packages, keeps active ones)")
            
            if not self.stale_packages:
                print("‚ú® No stale packages found!")
                return True
            
            stale_size = sum(p.stat().st_size for p in self.stale_packages if p.exists())
            print(f"Found {len(self.stale_packages)} stale entries ({self.format_size(stale_size)})")
            
            confirm = input("Delete stale cache entries? (y/n): ").strip().lower()
            
            if confirm != 'y':
                print("Cancelled.")
                return False
            
            print("üßπ Cleaning stale entries...")
            deleted = 0
            
            for pkg in self.stale_packages:
                try:
                    if pkg.exists():
                        pkg.unlink()
                        deleted += 1
                except:
                    pass
            
            print(f"‚úì Cleaned {deleted}/{len(self.stale_packages)} stale entries")
            print(f"‚úì Freed: {self.format_size(stale_size)}")
            
            # Verify after cleaning
            print("\nüîç Verifying cache integrity...")
            subprocess.run(['npm', 'cache', 'verify'], capture_output=True)
            
            return True
        
        return False


class CodeCleaner:
    """Main cleaner with professional output"""
    
    def __init__(self):
        self.stats = {'processed': 0, 'skipped': 0, 'errors': 0}
        self.processed_files = []
    
    def detect_language(self, file_path: Path) -> Optional[str]:
        """Auto-detect language from file extension"""
        ext = file_path.suffix.lower()
        for lang_code, config in LANGUAGE_CONFIG.items():
            if ext in config['extensions']:
                return lang_code
        return None
    
    def process_file(self, file_path: Path, mode: str = 'clean') -> bool:
        """Process a single file"""
        try:
            lang = self.detect_language(file_path)
            if not lang:
                return False
            
            with open(file_path, 'r', encoding='utf-8') as f:
                original = f.read()
            
            code = original
            
            # Process based on mode
            if mode == 'clean':
                remover = CommentRemover(lang)
                code = remover.remove_comments(code)
                code = SmartFormatter.format_code(code, lang)
            
            elif mode == 'add':
                adder = CommentAdder(lang)
                code = adder.add_comments(code)
                code = SmartFormatter.format_code(code, lang)
            
            elif mode == 'format':
                code = SmartFormatter.format_code(code, lang)
            
            elif mode == 'both':
                remover = CommentRemover(lang)
                code = remover.remove_comments(code)
                code = SmartFormatter.format_code(code, lang)
            
            if code == original:
                self.stats['skipped'] += 1
                return False
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            
            self.stats['processed'] += 1
            self.processed_files.append(str(file_path))
            print(f"‚úì {file_path}")
            return True
            
        except Exception as e:
            self.stats['errors'] += 1
            print(f"‚úó {file_path}: {str(e)}")
            return False
    
    def process_directory(self, path: Path, mode: str = 'clean') -> None:
        """Process all supported files in directory"""
        extensions = []
        for config in LANGUAGE_CONFIG.values():
            extensions.extend(config['extensions'])
        
        for ext in extensions:
            for file in path.rglob(f'*{ext}'):
                if file.is_file() and '.git' not in file.parts:
                    self.process_file(file, mode)
    
    def show_stats(self):
        """Display statistics"""
        print(f"\n{'='*50}")
        print(f"‚úì Processed: {self.stats['processed']}")
        print(f"‚óã Skipped: {self.stats['skipped']}")
        if self.stats['errors'] > 0:
            print(f"‚úó Errors: {self.stats['errors']}")
        print(f"{'='*50}")


def interactive_mode():
    """Interactive mode for easy use"""
    print("\n" + "="*50)
    print("üßπ CODE CLEANER - Interactive Mode")
    print("="*50)
    
    print("\nüéØ What do you want to do?")
    print("1. Clean code files (remove comments + format)")
    print("2. Add helpful comments to code")
    print("3. Format code only")
    print("4. Clean NPM cache (smart cleanup) üÜï")
    
    choice = input("Choose (1/2/3/4) [default: 1]: ").strip() or '1'
    
    # NPM cache cleaning
    if choice == '4':
        print("\nüì¶ NPM Cache Cleaner")
        print("This will analyze your npm cache and clean stale/corrupted entries")
        print("Active packages (used in your projects) will be preserved\n")
        
        confirm = input("Continue? (y/n) [default: y]: ").strip().lower()
        
        if confirm == 'n':
            print("Cancelled.")
            return
        
        cleaner = NPMCacheCleaner()
        info = cleaner.analyze_cache()
        
        if 'error' in info:
            print(f"‚ùå {info['error']}")
            print("Make sure npm is installed: npm --version")
            return
        
        cleaner.show_analysis(info)
        
        print("\nCleaning options:")
        print("1. Smart clean (remove stale, keep active)")
        print("2. Verify cache (fix corrupted entries)")
        print("3. Force clean (delete everything)")
        
        clean_choice = input("Choose (1/2/3) [default: 1]: ").strip() or '1'
        
        mode_map = {'1': 'smart', '2': 'verify', '3': 'force'}
        mode = mode_map.get(clean_choice, 'smart')
        
        cleaner.clean_cache(mode)
        
        return
    
    # Code cleaning (original functionality)
    path_input = input("\nüìÅ Path (press Enter for current folder): ").strip()
    path = Path(path_input) if path_input else Path('.')
    
    if not path.exists():
        print(f"‚ùå Path not found: {path}")
        return
    
    mode_map = {'1': 'clean', '2': 'add', '3': 'format'}
    mode = mode_map.get(choice, 'clean')
    
    git_push = input("\nüöÄ Push to GitHub? (y/n) [default: n]: ").strip().lower() == 'y'
    
    print(f"\nüìã Summary:")
    print(f"   Path: {path}")
    print(f"   Mode: {mode}")
    print(f"   Git: {'Yes' if git_push else 'No'}")
    
    confirm = input("\n‚ñ∂ Continue? (y/n) [default: y]: ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return
    
    print(f"\nüîÑ Processing...\n")
    cleaner = CodeCleaner()
    
    if path.is_file():
        cleaner.process_file(path, mode)
    else:
        cleaner.process_directory(path, mode)
    
    cleaner.show_stats()
    
    if git_push and cleaner.processed_files:
        print("\nüì§ Pushing to GitHub...")
        if QuickGit.auto_push(cleaner.processed_files):
            print("‚úì Successfully pushed!")
        else:
            print("‚úó Git push failed")


def main():
    """Main entry point"""
    
    if len(sys.argv) == 1:
        interactive_mode()
        return
    
    args = sys.argv[1:]
    
    # Handle system cleaning
    if args[0] in ['system', 'npm', 'cache']:
        handle_system_clean(args)
        return
    
    if args[0] in ['help', '--help', '-h']:
        print("""
üßπ CODE CLEANER - Quick Commands

INTERACTIVE:
  clean                    Interactive mode (easiest!)

CODE CLEANING:
  clean .                  Remove comments + format
  clean . add              Add helpful comments
  clean . push             Clean and push to GitHub
  clean file.py            Clean single file
  clean file.py add        Add comments to file

NPM CACHE CLEANING:
  clean system             Smart clean npm cache
  clean system --verify    Verify and fix corrupted cache
  clean system --force     Delete entire cache (like npm cache clean --force)

EXAMPLES:
  clean                    # Interactive (recommended)
  clean .                  # Clean current folder
  clean app.py             # Clean one file
  clean . add              # Add comments to document code
  clean ./src push         # Clean and push to GitHub
  clean system             # Clean npm cache intelligently

SUPPORTED: Python, JavaScript, TypeScript, Java, C/C++, Go, Rust, PHP
        """)
        return
    
    # Parse arguments
    path = Path(args[0])
    mode = 'clean'
    git_push = False
    
    if len(args) > 1:
        if 'add' in args[1]:
            mode = 'add'
        elif 'format' in args[1]:
            mode = 'format'
        elif 'push' in args[1]:
            git_push = True
    
    if len(args) > 2 and 'push' in args[2]:
        git_push = True
    
    if not path.exists():
        print(f"‚ùå Path not found: {path}")
        print("üí° Try: clean  (for interactive mode)")
        return
    
    # Process
    print(f"üîÑ Processing {path}...\n")
    cleaner = CodeCleaner()
    
    if path.is_file():
        cleaner.process_file(path, mode)
    else:
        cleaner.process_directory(path, mode)
    
    cleaner.show_stats()
    
    if git_push and cleaner.processed_files:
        print("\nüì§ Pushing to GitHub...")
        if QuickGit.auto_push(cleaner.processed_files):
            print("‚úì Successfully pushed!")
        else:
            print("‚úó Git push failed")


def handle_system_clean(args: List[str]):
    """Handle system cleaning commands"""
    
    print("\nüì¶ NPM Cache Cleaner\n")
    
    cleaner = NPMCacheCleaner()
    info = cleaner.analyze_cache()
    
    if 'error' in info:
        print(f"‚ùå {info['error']}")
        print("Make sure npm is installed: npm --version")
        return
    
    cleaner.show_analysis(info)
    
    # Determine mode
    mode = 'smart'
    if '--verify' in args:
        mode = 'verify'
    elif '--force' in args or '--all' in args:
        mode = 'force'
    
    cleaner.clean_cache(mode)


if __name__ == '__main__':
    main()
